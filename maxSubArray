//输出最大的和，个人感觉应该用分治算法，，太麻烦了写不出来，所以用了两次搜索，应该能解决不是很刁钻的问题，比如全是负数
//只通过了1/2的测试用例，待改进
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int len=nums.size();
        int indexl=0,indexr=len-1,maxsum=0;
        int temp[len];
        // 从左往右，计算加和，并保存在temp数组中

        for (int i=0,sum=0;i<len;i++){
            sum+=nums[i];
            temp[i]=sum;
                    // 和最大的下标保存在indexl中
            if (temp[i]>temp[indexl])  indexl=i;
        }
        
        for (int i=len-1,sum=0;i>=0;i--){
            sum+=nums[i];
            temp[i]=sum;
            if (temp[i]>temp[indexr])  indexr=i;
        }
        //判断下标的前后
        int left=(indexl<=indexr)?indexl:indexr;
        int right=(indexl>indexr)?indexl:indexr;
        
        for(int i=left;i<=right;i++){
            maxsum+=nums[i];
        }
        return maxsum;
    }
};
