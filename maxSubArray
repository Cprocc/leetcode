//输出最大的和，个人感觉应该用分治算法，，太麻烦了写不出来，所以用了两次搜索，应该能解决不是很刁钻的问题，比如全是负数
//只通过了1/2的测试用例，待改进
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int len=nums.size();
        int mockl=0,mockr=0;
        //将数组有效长度减少（从第一个不为0的数，到最后一个不为0的数）
        for(int i=0;i<len;i++){
         if(nums[i]>=0) {mockl=i;break;} 
         else mockl=0;
        }
         for(int i=len-1;i>=0;i--){
         if(nums[i]>=0) {mockr=i;break;}
         else mockr=0;
        }
        //需要修改
        if(mockl==mockr) {
        for(int i=0;i<len;i++){
         if(nums[i]>=0) {mockl=i;break;} 
         else mockl=0;
        }
        }
          
        int indexl=0, indexr=len-1,maxsum=0;
        int temp[mockr-mock1];
        // 从左往右，计算加和，并保存在temp数组中

        for (int i=0,sum=0;i<len;i++){
            sum+=nums[i];
            temp[i]=sum;
                    // 和最大的下标保存在indexl中
            if (temp[i]>temp[indexl])  indexl=i;
        }
        
        for (int i=len-1,sum=0;i>=0;i--){
            sum+=nums[i];
            temp[i]=sum;
            if (temp[i]>temp[indexr])  indexr=i;
        }
        //判断下标的前后
        int left=(indexl<=indexr)?indexl:indexr;
        int right=(indexl>indexr)?indexl:indexr;
        
        for(int i=left;i<=right;i++){
            maxsum+=nums[i];
        }
        return maxsum;
    }
};
